(define fcons (lambda (x y) (lambda (p) (if p x y))))
(define fcar (lambda (pair) (pair #t)))
(define fcdr (lambda (pair) (pair #f)))

(deftype List)

(defrep Default List)
(defconstructor List:Default (lambda (x (List y)) (cons x y)))

(defrep Functional List)
(defconstructor List:Functional (lambda (x (List y)) (fcons x y)))
(defconversion List:Default List:Functional (lambda ((ListDefault l)) (fcons (car l) (cdr l))))
(defconversion List:Functional List:Default (lambda ((List:Functional l)) (cons (fcar l) (fcdr l))))

(defrep Empty List)
(defconstructor List:Empty (lambda () nil))
(defconversion List:Empty List:Default (lambda ((List:Empty l)) l))
(defconversion List:Empty List:Functional (lambda ((List:Empty l)) l))

(define x (List:Default 1 (List:Default 2 (List:Default 3 (List:Empty)))))

(define head-list (elambda (l) (error "head-list function not implemented for this representation!")
          					((List) (car l))
          					((List:Functional) (fcar l))
          					((List:Empty) (error "Cannot make head of empty list!"))))

(define tail-list (elambda (l) (error "tail-list function not implemented for this representation")
          					(List) (cdr l)
          					(List:Functional) (fcdr l)
          					(List:Empty) (error "Cannot make tail of empty list!"))))
(define build-list-aux (lambda (i n f)
            						(if (= i n)
            							(List:Empty)
            							(List (f i) (build-list-aux (+ i 1) n f))))
(define build-list (lambda (n f) (build-list-aux 0 n f)))
(define append-list (lambda ((List l) x) 
						(if (equals? l (List:Empty)) 
							(List x (List:Empty)) 
							(List (head-list l) (append-list (tail-list l) x)))))
(define reverse-list (lambda ((List l)) 
						(if (equals? l (List:Empty)) 
							(List:Empty) 
							(append-list (reverse-list (tail-list l)) (head-list l)))))